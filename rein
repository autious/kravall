./src/gfx/Renderer/RenderJobManager.cpp:		GFX::RenderJobManager::RenderJob arg1 = *reinterpret_cast<const GFX::RenderJobManager::RenderJob*>(a);
./src/gfx/Renderer/RenderJobManager.cpp:		GFX::RenderJobManager::RenderJob arg2 = *reinterpret_cast<const GFX::RenderJobManager::RenderJob*>(b);
./src/gfx/Renderer/DeferredRenderer/LightPainter.cpp:				m_lights[numLights] = *reinterpret_cast<LightData*>(renderJobs[i].value);
./src/core/Systems/CollisionSystem2D.cpp:			if( reinterpret_cast<Core::BoundingSphere*>(bvc->data)->radius > maxRadius )
./src/core/Systems/CollisionSystem2D.cpp:				maxRadius = reinterpret_cast<Core::BoundingSphere*>(bvc->data)->radius;
./src/core/Systems/CollisionSystem2D.cpp:		glm::vec3 myPosition = *reinterpret_cast<glm::vec3*>(wpc->position);
./src/core/Systems/CollisionSystem2D.cpp:		Core::BoundingSphere* mySphere = reinterpret_cast<Core::BoundingSphere*>( bvc->data );
./src/core/Systems/CollisionSystem2D.cpp:			glm::vec3 otherPosition = *reinterpret_cast<glm::vec3*>(wpcOther->position);
./src/core/Systems/CollisionSystem2D.cpp:			Core::BoundingSphere* otherSphere = reinterpret_cast<Core::BoundingSphere*>( bvcOther->data );
./src/core/Systems/CollisionSystem2D.cpp:					*reinterpret_cast<glm::vec3*>(wpc->position) += glm::vec3( 0.01f, 0.0f, 0.0f );
./src/core/Systems/CollisionSystem2D.cpp:					myPosition = *reinterpret_cast<glm::vec3*>(wpc->position);
./src/core/Systems/CollisionSystem2D.cpp:				if( glm::dot( collisionNormal, *reinterpret_cast<glm::vec3*>(mvmc->direction) ) < -0.999 )
./src/core/Systems/CollisionSystem2D.cpp:						*reinterpret_cast<glm::vec3*>(wpc->position) += moveDir * 0.1f;
./src/core/Systems/CollisionSystem2D.cpp:						myPosition = *reinterpret_cast<glm::vec3*>(wpc->position);
./src/core/Systems/CollisionSystem2D.cpp:					*reinterpret_cast<glm::vec3*>(wpc->position)		+= collisionNormal * ( delta * 0.5f );
./src/core/Systems/CollisionSystem2D.cpp:					*reinterpret_cast<glm::vec3*>(wpcOther->position)	-= collisionNormal * ( delta * 0.5f );
./src/core/Systems/CollisionSystem2D.cpp:					*reinterpret_cast<glm::vec3*>(wpc->position) += collisionNormal * delta;
./src/core/Systems/CollisionSystem2D.cpp:			glm::vec3 myPosition = *reinterpret_cast<glm::vec3*>(wpc->position);
./src/core/Systems/CollisionSystem2D.cpp:			Core::BoundingSphere* mySphere = reinterpret_cast<Core::BoundingSphere*>( bvc->data );
./src/core/Systems/CollisionSystem2D.cpp:					glm::vec3 otherPosition = *reinterpret_cast<glm::vec3*>(wpcOther->position);
./src/core/Systems/CollisionSystem2D.cpp:					Core::BoundingSphere* otherSphere = reinterpret_cast<Core::BoundingSphere*>( bvcOther->data );
./src/core/Systems/CollisionSystem2D.cpp:							*reinterpret_cast<glm::vec3*>(wpc->position) += glm::vec3( 0.01f, 0.0f, 0.0f );
./src/core/Systems/CollisionSystem2D.cpp:							myPosition = *reinterpret_cast<glm::vec3*>(wpc->position);
./src/core/Systems/CollisionSystem2D.cpp:						if( glm::dot( collisionNormal, *reinterpret_cast<glm::vec3*>(mvmc->direction) ) < -0.999 )
./src/core/Systems/CollisionSystem2D.cpp:								*reinterpret_cast<glm::vec3*>(wpc->position) += moveDir * 0.1f;
./src/core/Systems/CollisionSystem2D.cpp:								myPosition = *reinterpret_cast<glm::vec3*>(wpc->position);
./src/core/Systems/CollisionSystem2D.cpp:								*reinterpret_cast<glm::vec3*>(wpc->position)		+= collisionNormal * ( delta * 1.0f );
./src/core/Systems/CollisionSystem2D.cpp:								*reinterpret_cast<glm::vec3*>(wpc->position)		+= collisionNormal * ( delta * 0.5f );
./src/core/Systems/CollisionSystem2D.cpp:								*reinterpret_cast<glm::vec3*>(wpcOther->position)	-= collisionNormal * ( delta * 0.5f );
./src/core/Systems/CollisionSystem2D.cpp:							*reinterpret_cast<glm::vec3*>(wpc->position) += collisionNormal * delta;
./src/core/Systems/CollisionSystem2D.cpp:			glm::vec3 myPosition = *reinterpret_cast<glm::vec3*>(wpc->position);
./src/core/Systems/CollisionSystem2D.cpp:			Core::BoundingSphere* mySphere = reinterpret_cast<Core::BoundingSphere*>( bvc->data );
./src/core/Systems/CollisionSystem2D.cpp:					glm::vec3 otherPosition = *reinterpret_cast<glm::vec3*>(wpcOther->position);
./src/core/Systems/CollisionSystem2D.cpp:					Core::BoundingSphere* otherSphere = reinterpret_cast<Core::BoundingSphere*>( bvcOther->data );
./src/core/Systems/CollisionSystem2D.cpp:							*reinterpret_cast<glm::vec3*>(wpc->position) += glm::vec3( 0.01f, 0.0f, 0.0f );
./src/core/Systems/CollisionSystem2D.cpp:							myPosition = *reinterpret_cast<glm::vec3*>(wpc->position);
./src/core/Systems/CollisionSystem2D.cpp:						if( glm::dot( collisionNormal, *reinterpret_cast<glm::vec3*>(mvmc->direction) ) < -0.999 )
./src/core/Systems/CollisionSystem2D.cpp:								*reinterpret_cast<glm::vec3*>(wpc->position) += moveDir * 0.1f;
./src/core/Systems/CollisionSystem2D.cpp:								myPosition = *reinterpret_cast<glm::vec3*>(wpc->position);
./src/core/Systems/CollisionSystem2D.cpp:								*reinterpret_cast<glm::vec3*>(wpc->position)		+= collisionNormal * ( delta * 0.2f );
./src/core/Systems/CollisionSystem2D.cpp:								*reinterpret_cast<glm::vec3*>(wpcOther->position)	-= collisionNormal * ( delta * 0.8f );
./src/core/Systems/CollisionSystem2D.cpp:								*reinterpret_cast<glm::vec3*>(wpc->position)		+= collisionNormal * ( delta * 0.5f );
./src/core/Systems/CollisionSystem2D.cpp:								*reinterpret_cast<glm::vec3*>(wpcOther->position)	-= collisionNormal * ( delta * 0.5f );
./src/core/Systems/CollisionSystem2D.cpp:							*reinterpret_cast<glm::vec3*>(wpc->position) += collisionNormal * delta;
./src/core/Systems/CollisionSystem2D.cpp:		glm::vec3 myPosition = *reinterpret_cast<glm::vec3*>(wpc->position);
./src/core/Systems/CollisionSystem2D.cpp:			glm::vec3 otherPosition = *reinterpret_cast<glm::vec3*>(wpcOther->position);
./src/core/Systems/MovementSystem.cpp:				*reinterpret_cast<glm::vec3*>(mc->goal) - *reinterpret_cast<glm::vec3*>(wpc->position), 
./src/core/Systems/MovementSystem.cpp:				*reinterpret_cast<glm::vec3*>(mc->goal) - *reinterpret_cast<glm::vec3*>(wpc->position) ) > 0.5f )
./src/core/Systems/MovementSystem.cpp:				*reinterpret_cast<glm::vec3*>(mc->direction) = glm::normalize(*reinterpret_cast<glm::vec3*>(mc->goal) - *reinterpret_cast<glm::vec3*>(wpc->position));
./src/core/Systems/FlowfieldPositioningSystem.cpp:			glm::vec3 position = *reinterpret_cast<glm::vec3*>(wpc->position);
./src/core/Systems/AIDebugSystem.cpp:		Core::BoundingSphere* sphere = reinterpret_cast<Core::BoundingSphere*>(bvc->data);
./src/core/Systems/AIDebugSystem.cpp:		GFX::Debug::DrawSphere( wpc->GetVec3(*wpc) + *reinterpret_cast<glm::vec3*>( sphere->offset ), sphere->radius, GFXColor( 1.0f, 0.7f, 0.0f, 1.0f ), false );
./src/core/Systems/NavMeshCollisionSystem.cpp:			Core::BoundingSphere& sphere = *reinterpret_cast<Core::BoundingSphere*>(bvc->data);
./src/core/Systems/NavMeshCollisionSystem.cpp:			glm::vec3& position = *reinterpret_cast<glm::vec3*>(wpc->position);
./src/core/Systems/NavMeshCollisionSystem.cpp:				glm::vec3 fromStartToObject = position + *reinterpret_cast<glm::vec3*>( sphere.offset ) - lineStart;
./src/core/Systems/NavMeshCollisionSystem.cpp:					glm::dot( position + *reinterpret_cast<glm::vec3*>( sphere.offset ) - lineStart, 
./src/core/Systems/NavMeshCollisionSystem.cpp:								position + *reinterpret_cast<glm::vec3*>( sphere.offset ) - lineStart );
./src/core/Systems/NavMeshCollisionSystem.cpp:					position += glm::normalize( position + *reinterpret_cast<glm::vec3*>( sphere.offset ) - lineStart ) 
./src/core/Systems/NavMeshCollisionSystem.cpp:				Core::BoundingSphere& sphere = *reinterpret_cast<Core::BoundingSphere*>(bvc->data);
./src/core/Systems/NavMeshCollisionSystem.cpp:				glm::vec3& position = *reinterpret_cast<glm::vec3*>(wpc->position);
./src/core/Systems/NavMeshCollisionSystem.cpp:					glm::vec3 fromStartToObject = position + *reinterpret_cast<glm::vec3*>( sphere.offset ) - lineStart;
./src/core/Systems/NavMeshCollisionSystem.cpp:						glm::dot( position + *reinterpret_cast<glm::vec3*>( sphere.offset ) - lineStart, 
./src/core/Systems/NavMeshCollisionSystem.cpp:								  position + *reinterpret_cast<glm::vec3*>( sphere.offset ) - lineStart );
./src/core/Systems/NavMeshCollisionSystem.cpp:						position += glm::normalize( position + *reinterpret_cast<glm::vec3*>( sphere.offset ) - lineStart ) 
./src/core/Systems/FlowfieldSystem.cpp:			glm::vec3& position = *reinterpret_cast<glm::vec3*>(wpc->position);
./src/core/Systems/FlowfieldSystem.cpp:				*reinterpret_cast<glm::vec3*>(mvmc->direction) = glm::normalize( 
./src/core/Systems/FlowfieldSystem.cpp:					- *reinterpret_cast<glm::vec3*>( instance->nodes[ ffc->node ].corners[ instance->flowfields[attribc->rioter.groupID].edges[ffc->node] ].normal ) * FF_NORMAL_INFLUENCE ); 
./src/core/Systems/FlowfieldSystem.cpp:				*reinterpret_cast<glm::vec3*>(mvmc->direction) = glm::vec3(0.0f);
./src/core/Systems/FieldReactionSystem.cpp:				*reinterpret_cast<glm::vec3*>(mc->direction) = glm::normalize( 
./src/core/Systems/FieldReactionSystem.cpp:					*reinterpret_cast<glm::vec3*>(mc->direction) + 
./src/core/Systems/FieldReactionSystem.cpp:			glm::vec3 position = *reinterpret_cast<glm::vec3*>(wpc->position);
./src/core/Systems/FieldReactionSystem.cpp:			GFX::Debug::DrawLine( position, position + *reinterpret_cast<glm::vec3*>(mc->direction), GFXColor( 1.0f, 0.0f, 0.0f, 1.0f ), false );
./src/core/Systems/PickingSystem.cpp:			glm::vec3 toSphere = wpc->GetVec3(*wpc) + *reinterpret_cast<glm::vec3*>(sphere->offset) - rayOrigin;
./src/core/GameUtility/NavigationMesh.cpp:		*reinterpret_cast<glm::vec3*>(node.corners[i].normal) = cross;
./src/core/ContentManagement/Loaders/NavigationMeshLoader.cpp:		Core::SetNavigationMesh( reinterpret_cast<Core::NavigationMesh*>(handle) );
./src/core/ContentManagement/Loaders/GnomeLoader.cpp:            handle = reinterpret_cast<AssetHandle>(modelData);
./src/core/Lua/Bridges/ComponentBind/BoundingVolumeComponentBinding.cpp:        lua_pushnumber( L, reinterpret_cast<BoundingSphere*>(bvc->data)->radius );   
./src/core/Lua/Bridges/ComponentBind/BoundingVolumeComponentBinding.cpp:            lua_pushnumber( L, reinterpret_cast<BoundingSphere*>(bvc->data)->offset[i] );
./src/core/Lua/Bridges/ComponentBind/BoundingVolumeComponentBinding.cpp:            reinterpret_cast<Core::BoundingSphere*>(bvc->data)->radius = static_cast<float>(lua_tonumber( L, valueindex ));
./src/core/Lua/Bridges/ComponentBind/BoundingVolumeComponentBinding.cpp:                    reinterpret_cast<Core::BoundingSphere*>(bvc->data)->offset[i] = static_cast<float>(lua_tonumber( L, -1 ));  
./src/core/Memory/StackHeap.hpp:           return reinterpret_cast<unsigned char*>(finalizer) + sizeof(Core::Finalizer);
./src/core/Memory/LinearHeap.hpp:			char* objects = reinterpret_cast<char*>(m_allocator.Allocate(sizeof(T) * size));
./src/core/Memory/LinearHeap.hpp:				(*static_cast<T*>(reinterpret_cast<void*>(objects+sizeof(T)*i))) = T(args...);
./src/core/Memory/LinearHeap.hpp:				(*static_cast<Core::Finalizer*>(reinterpret_cast<void*>(destructors+sizeof(Core::Finalizer)*i))).m_dataPointer = static_cast<T*>(reinterpret_cast<void*>(objects+sizeof(T)*i));
./src/core/Memory/LinearHeap.hpp:				(*static_cast<Core::Finalizer*>(reinterpret_cast<void*>(destructors+sizeof(Core::Finalizer)*i))).m_destructorCall = &DestructorCall<T>;
./src/core/Memory/LinearHeap.hpp:				(*static_cast<Core::Finalizer*>(reinterpret_cast<void*>(destructors+sizeof(Core::Finalizer)*i))).m_finalizerChain = m_finalizerChain;
./src/core/Memory/LinearHeap.hpp:			return static_cast<T*>(reinterpret_cast<void*>(objects));
